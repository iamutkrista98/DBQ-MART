--------------------------------------------------------------
-- Database creation Script

-- Auto-Generated by QSEE-SuperLite (c) 2001-2004 QSEE-Technologies Ltd.

-- Verbose generation: ON

-- note: spaces within table/column names have been replaced by underscores (_)

-- Target DB: SQL2

-- Entity Model :DBQ MART Composite Extended Entity Relationship Diagram

-- To drop the tables generated by this script run -
--   'C:\Users\iamut\Desktop\script\dbq_drop.sql'

--------------------------------------------------------------



--------------------------------------------------------------
-- Table Creation --

-- Each entity on the model is represented by a table that needs to be created within the Database.
-- Within SQL new tables are created using the CREATE TABLE command.
-- When a table is created its name and its attributes are defined.
-- The values of which are derived from those specified on the model.
-- Certain constraints are sometimes also specified, such as identification of primary keys.

--DROP TABLE COMMANDS--

--------------------------------------------------------------
-- Database table removal script

-- Auto-Generated by QSEE-SuperLite (c) 2001-2004 QSEE-Technologies Ltd.

-- note: spaces within table names have been replaced by underscores (_)

-- Target DB: SQL2

-- Entity Model :DBQ MART Composite Extended Entity Relationship Diagram

-- Use this script to drop the tables created by -
--   'C:\Users\iamut\Desktop\script\dbq.sql'

-- Dropping a table has the effect of removing it from the Database.  All existing data is lost
-- as well as the definition of the table itself (stored as meta-data).  Dropping the tables allows
-- them to be re-created within the Database, even if they already exist.


--------------------------------------------------------------

-- Drop tables --
DROP TABLE USERS CASCADE CONSTRAINTS;

DROP TABLE OFFER_corresponds_to_PRODUCT CASCADE CONSTRAINTS;

DROP TABLE DISCOUNT_is_availed_on_PRODUCT CASCADE CONSTRAINTS;

DROP TABLE ORDERS_ORDERS_PRODUCT CASCADE CONSTRAINTS;

DROP TABLE TRADER CASCADE CONSTRAINTS;

DROP TABLE CUSTOMER CASCADE CONSTRAINTS;

DROP TABLE ADMIN CASCADE CONSTRAINTS;

DROP TABLE DISCOUNT CASCADE CONSTRAINTS;

DROP TABLE COLLECTION_POINT CASCADE CONSTRAINTS;

DROP TABLE WISHLIST CASCADE CONSTRAINTS;

DROP TABLE OFFER CASCADE CONSTRAINTS;

DROP TABLE PAYMENT CASCADE CONSTRAINTS;

DROP TABLE ORDERS CASCADE CONSTRAINTS;

DROP TABLE PRODUCT CASCADE CONSTRAINTS;

DROP TABLE REVIEW CASCADE CONSTRAINTS;

DROP TABLE RECEIPT CASCADE CONSTRAINTS;

DROP TABLE CART CASCADE CONSTRAINTS;


DROP TABLE SHOP CASCADE CONSTRAINTS;

DROP TABLE CART_PRODUCT CASCADE CONSTRAINTS;

DROP TABLE ORDERS_PRODUCT CASCADE CONSTRAINTS;

DROP TABLE WISHLIST_PRODUCT CASCADE CONSTRAINTS;

DROP TABLE PRODUCT_TYPE CASCADE CONSTRAINTS;


--------------------------------------------------------------
-- End of DDL DROP file auto-generation
--------------------------------------------------------------


-- Create a Database table to represent the "DISCOUNT" entity.
CREATE TABLE DISCOUNT(
	Discount_Id	VARCHAR2(350) NOT NULL,
	Discount_Rate	DOUBLE PRECISION,
	Discount_Start	DATE,
	Discount_Expiry	DATE,
	fk1_User_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "DISCOUNT".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_DISCOUNT PRIMARY KEY (Discount_Id)
);

-- Create a Database table to represent the "COLLECTION_POINT" entity.
CREATE TABLE COLLECTION_POINT(
	Collection_Id	VARCHAR2(350) NOT NULL,
	Collection_Date	DATE,
	Collection_Time	VARCHAR2(350),
	fk1_Payment_Id	VARCHAR2(350) NOT NULL,
	-- Specify FK as unique to maintain 1:1 relationship
	UNIQUE(fk1_Payment_Id),
	-- Specify the PRIMARY KEY constraint for table "COLLECTION_POINT".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_COLLECTION_POINT PRIMARY KEY (Collection_Id)
);

-- Create a Database table to represent the "WISHLIST" entity.
CREATE TABLE WISHLIST(
	Wishlist_Id	VARCHAR2(350) NOT NULL,
	fk1_User_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "WISHLIST".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_WISHLIST PRIMARY KEY (Wishlist_Id)
);

-- Create a Database table to represent the "OFFER" entity.
CREATE TABLE OFFER(
	Offer_Id	VARCHAR2(350) NOT NULL,
	Offer_Type	VARCHAR2(350),
	Offer_Start	DATE,
	Offer_Expiry DATE,
	fk1_Shop_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "OFFER".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_OFFER PRIMARY KEY (Offer_Id)
);

-- Create a Database table to represent the "PAYMENT" entity.
CREATE TABLE PAYMENT(
	Payment_Id	VARCHAR2(350) NOT NULL,
	Payment_Date DATE,
	Total_Amount NUMBER(10,2),
	fk1_User_Id	VARCHAR2(350) NOT NULL,
	fk2_Order_Id VARCHAR(350) NOT NULL,
	-- Specify FK as unique to maintain 1:1 relationship
	UNIQUE(fk2_Order_Id),
	-- Specify the PRIMARY KEY constraint for table "PAYMENT".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_PAYMENT PRIMARY KEY (Payment_Id)
);

-- Create a Database table to represent the "ORDER" entity.
CREATE TABLE ORDERS(
	Order_Id VARCHAR2(350) NOT NULL,
	Order_Date	DATE,
	Order_Quantity INTEGER,
	fk1_Cart_Id	VARCHAR2(350) NOT NULL,
	-- Specify FK as unique to maintain 1:1 relationship
	UNIQUE(fk1_Cart_Id),
	-- Specify the PRIMARY KEY constraint for table "ORDER".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_ORDER PRIMARY KEY (Order_Id)
);

-- Create a Database table to represent the "PRODUCT" entity.
CREATE TABLE PRODUCT(
	Product_Id	VARCHAR2(350) NOT NULL,
	Product_Name	VARCHAR2(350),
	Product_Price	DECIMAL(10,2),
	Product_Stock	INTEGER,
	Product_Detail	VARCHAR2(350),
	Maximum_Order	INTEGER,
	Minimum_Order	INTEGER,
	Allergy_Information	VARCHAR2(350),
	fk1_Shop_Id	VARCHAR2(350) NOT NULL,
	fk2_Product_Type_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "PRODUCT".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_PRODUCT PRIMARY KEY (Product_Id)
);

-- Create a Database table to represent the "REVIEW" entity.
CREATE TABLE REVIEW(
	Review_Id	VARCHAR2(350) NOT NULL,
	Review_Description	VARCHAR(350),
	Review_Date	DATE,
	Review_Time	VARCHAR2(350),
	fk1_Product_Id	VARCHAR2(350) NOT NULL,
	fk2_User_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "REVIEW".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_REVIEW PRIMARY KEY (Review_Id)
);

-- Create a Database table to represent the "RECEIPT" entity.
CREATE TABLE RECEIPT(
	Receipt_Id	VARCHAR2(350) NOT NULL,
	fk1_User_Id	VARCHAR2(350) NOT NULL,
	-- Specify FK as unique to maintain 1:1 relationship
	UNIQUE(fk1_User_Id),
	fk2_Payment_Id	VARCHAR2(350) NOT NULL,
	-- Specify FK as unique to maintain 1:1 relationship
	UNIQUE(fk2_Payment_Id),
	-- Specify the PRIMARY KEY constraint for table "RECEIPT".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_RECEIPT PRIMARY KEY (Receipt_Id)
);

-- Create a Database table to represent the "CART" entity.
CREATE TABLE CART(
	Cart_Id	VARCHAR2(350) NOT NULL,
	fk1_User_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "CART".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_CART PRIMARY KEY (Cart_Id)
);

-- Create a Database table to represent the "USER" entity.
CREATE TABLE USERS(
	User_Id	VARCHAR2(350) NOT NULL,
	Email	VARCHAR2(360),
	Address	VARCHAR2(350),
	Contact_No	VARCHAR2(350),
	DOB	DATE,
	Gender	VARCHAR2(350),
	Status	NUMBER,
	-- Specify the PRIMARY KEY constraint for table "USER".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_USER PRIMARY KEY (User_Id)
);

-- Create a Database table to represent the "SHOP" entity.
CREATE TABLE SHOP(
	Shop_Id	VARCHAR2(350) NOT NULL,
	Shop_Name	VARCHAR2(350),
	fk1_User_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "SHOP".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_SHOP PRIMARY KEY (Shop_Id)
);

-- Create a Database table to represent the "CART_PRODUCT" entity.
CREATE TABLE CART_PRODUCT(
	Cart_Product_Id	VARCHAR2(350) NOT NULL,
	fk1_Cart_Id	VARCHAR2(350) NOT NULL,
	fk2_Product_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "CART_PRODUCT".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_CART_PRODUCT PRIMARY KEY (Cart_Product_Id)
);

-- Create a Database table to represent the "ORDER_PRODUCT" entity.
CREATE TABLE ORDERS_PRODUCT(
	Order_Product_Id	VARCHAR2(350) NOT NULL,
	fk1_Product_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "ORDER_PRODUCT".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_ORDER_PRODUCT PRIMARY KEY (Order_Product_Id)
);

-- Create a Database table to represent the "WISHLIST_PRODUCT" entity.
CREATE TABLE WISHLIST_PRODUCT(
	Wishlist_Product_Id	VARCHAR2(350) NOT NULL,
	fk1_Product_Id	VARCHAR2(350) NOT NULL,
	fk2_Wishlist_Id	VARCHAR2(350) NOT NULL,
	-- Specify the PRIMARY KEY constraint for table "WISHLIST_PRODUCT".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_WISHLIST_PRODUCT PRIMARY KEY (Wishlist_Product_Id)
);

-- Create a Database table to represent the "PRODUCT_TYPE" entity.
CREATE TABLE PRODUCT_TYPE(
	Product_Type_Id	VARCHAR2(350) NOT NULL,
	Product_Type_Name	VARCHAR2(350),
	Product_Type_Description	VARCHAR2(350),
	-- Specify the PRIMARY KEY constraint for table "PRODUCT_TYPE".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_PRODUCT_TYPE PRIMARY KEY (Product_Type_Id)
);

-- Create a Database table to represent the "TRADER" entity.
-- This table is representing a sub-type entity, so the primary key will be the same as that
-- defined for table "USER" which represents the super-type entity.
CREATE TABLE TRADER(
	User_Id	VARCHAR2(350) NOT NULL,
	Trader_Name	VARCHAR2(350),
	-- Specify the PRIMARY KEY constraint for table "TRADER".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_TRADER PRIMARY KEY (User_Id),
	-- Specify a FOREIGN KEY constraint to indicate that this table's primary key (User_Id)
	-- references the super-type table's primary key. In this case the key of table "USER"
	-- The ON DELETE CASCADE and ON UPDATE CASCADE ensure that if the super-type key data is
	-- deleted or updated then the changes will be cascaded down to this sub-type.
	--  i.e. if the value of the super-type key is changed the value of this table's key is also changed.
	FOREIGN KEY(User_Id) REFERENCES USERS(User_Id)
);

-- Create a Database table to represent the "CUSTOMER" entity.
-- This table is representing a sub-type entity, so the primary key will be the same as that
-- defined for table "USER" which represents the super-type entity.
CREATE TABLE CUSTOMER(
	User_Id	VARCHAR2(350) NOT NULL,
	Customer_Name	VARCHAR2(350),
	-- Specify the PRIMARY KEY constraint for table "CUSTOMER".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_CUSTOMER PRIMARY KEY (User_Id),
	-- Specify a FOREIGN KEY constraint to indicate that this table's primary key (User_Id)
	-- references the super-type table's primary key. In this case the key of table "USER"
	-- The ON DELETE CASCADE and ON UPDATE CASCADE ensure that if the super-type key data is
	-- deleted or updated then the changes will be cascaded down to this sub-type.
	--  i.e. if the value of the super-type key is changed the value of this table's key is also changed.
	FOREIGN KEY(User_Id) REFERENCES USERS(User_Id)
);

-- Create a Database table to represent the "ADMIN" entity.
-- This table is representing a sub-type entity, so the primary key will be the same as that
-- defined for table "USER" which represents the super-type entity.
CREATE TABLE ADMIN(
	User_Id	VARCHAR2(350) NOT NULL,
	Admin_Name	VARCHAR2(350),
	-- Specify the PRIMARY KEY constraint for table "ADMIN".
	-- This indicates which attribute(s) uniquely identify each row of data.
	CONSTRAINT	pk_ADMIN PRIMARY KEY (User_Id),
	-- Specify a FOREIGN KEY constraint to indicate that this table's primary key (User_Id)
	-- references the super-type table's primary key. In this case the key of table "USER"
	-- The ON DELETE CASCADE and ON UPDATE CASCADE ensure that if the super-type key data is
	-- deleted or updated then the changes will be cascaded down to this sub-type.
	--  i.e. if the value of the super-type key is changed the value of this table's key is also changed.
	FOREIGN KEY(User_Id) REFERENCES USERS(User_Id)
);


--------------------------------------------------------------
-- Create LINK tables --

-- These tables do not appear as entities on the model. The reason they are created
-- is to allow certain types of relationships to be implemented in a Relational type Database.
-- Each link table tends to represent a specific relationship that appears on the model.
-- The attributes contained in link tables are identified from the entities at either side
-- of the relationship. i.e. they do not define attributes in their own right.
-- Indeed foreign key constraints are always created to ensure referential integrity between the
-- link table attributes and the primary key attributes on which they are based.

-- Create a link table to represent the "corresponds_to" relationship.
-- The attributes of this table are taken from the primary keys of table "OFFER" and
-- table "PRODUCT", i.e. each end of the relationship. A link table was created
-- because "corresponds_to" is a one to many relationship with optionality at the one side.
-- notice how the primary key is only based on the key of the table at the many side, i.e. table "PRODUCT".
CREATE TABLE OFFER_corresponds_to_PRODUCT(
	s_Offer_Id	VARCHAR2(350) NOT NULL,
	d_Product_Id	VARCHAR2(350) NOT NULL,
	PRIMARY KEY (d_Product_Id),
	FOREIGN KEY(s_Offer_Id) REFERENCES OFFER(Offer_Id),
	FOREIGN KEY(d_Product_Id) REFERENCES PRODUCT(Product_Id)
);

-- Create a link table to represent the "is_availed_on" relationship.
-- The attributes of this table are taken from the primary keys of table "DISCOUNT" and
-- table "PRODUCT", i.e. each end of the relationship. A link table was created
-- because "is_availed_on" is a one to many relationship with optionality at the one side.
-- notice how the primary key is only based on the key of the table at the many side, i.e. table "PRODUCT".
CREATE TABLE DISCOUNT_is_availed_on_PRODUCT(
	s_Discount_Id	VARCHAR2(350) NOT NULL,
	d_Product_Id	VARCHAR2(350) NOT NULL,
	PRIMARY KEY (d_Product_Id),
	FOREIGN KEY(s_Discount_Id) REFERENCES DISCOUNT(Discount_Id),
	FOREIGN KEY(d_Product_Id) REFERENCES PRODUCT(Product_Id)
);

-- Create a link table to represent the "ORDER_ORDER_PRODUCT" relationship.
-- The attributes of this table are taken from the primary keys of table "ORDER" and
-- table "ORDER_PRODUCT", i.e. each end of the relationship. A link table was created
-- because "ORDER_ORDER_PRODUCT" is a one to many relationship with optionality at the one side.
-- notice how the primary key is only based on the key of the table at the many side, i.e. table "ORDER_PRODUCT".
CREATE TABLE ORDERS_ORDERS_PRODUCT(
	s_Order_Id	VARCHAR2(350) NOT NULL,
	d_Order_Product_Id	VARCHAR2(350) NOT NULL,
	PRIMARY KEY (d_Order_Product_Id),
	FOREIGN KEY(s_Order_Id) REFERENCES ORDERS(Order_Id),
	FOREIGN KEY(d_Order_Product_Id) REFERENCES ORDERS_PRODUCT(Order_Product_Id)
);



/*
--------------------------------------------------------------
-- Alter Tables to add fk constraints --

-- Now all the tables have been created the ALTER TABLE command is used to define some additional
-- constraints.  These typically constrain values of foreign keys to be associated in some way
-- with the primary keys of related tables.  Foreign key constraints can actually be specified
-- when each table is created, but doing so can lead to dependency problems within the script
-- i.e. tables may be referenced before they have been created.  This method is therefore safer.

-- Alter table to add new constraints required to implement the "corresponds_to" relationship

-- This constraint ensures that the foreign key of table "REVIEW"
-- correctly references the primary key of table "PRODUCT"

ALTER TABLE REVIEW ADD CONSTRAINT fk1_REVIEW_to_PRODUCT FOREIGN KEY(fk1_Product_Id) REFERENCES PRODUCT(Product_Id);

-- Alter table to add new constraints required to implement the "gives" relationship

-- This constraint ensures that the foreign key of table "OFFER"
-- correctly references the primary key of table "SHOP"

ALTER TABLE OFFER ADD CONSTRAINT fk1_OFFER_to_SHOP FOREIGN KEY(fk1_Shop_Id) REFERENCES SHOP(Shop_Id);

-- Alter table to add new constraints required to implement the "contains" relationship

-- This constraint ensures that the foreign key of table "PRODUCT"
-- correctly references the primary key of table "SHOP"

ALTER TABLE PRODUCT ADD CONSTRAINT fk1_PRODUCT_to_SHOP FOREIGN KEY(fk1_Shop_Id) REFERENCES SHOP(Shop_Id);

-- Alter table to add new constraints required to implement the "holds" relationship

-- This constraint ensures that the foreign key of table "ORDER"
-- correctly references the primary key of table "CART"

ALTER TABLE ORDERS ADD CONSTRAINT fk1_ORDERS_to_CART FOREIGN KEY(fk1_Cart_Id) REFERENCES CART(Cart_Id);

-- Alter table to add new constraints required to implement the "can_leave" relationship

-- This constraint ensures that the foreign key of table "REVIEW"
-- correctly references the primary key of table "CUSTOMER"

ALTER TABLE REVIEW ADD CONSTRAINT fk2_REVIEW_to_CUSTOMER FOREIGN KEY(fk2_User_Id) REFERENCES CUSTOMER(User_Id);

-- Alter table to add new constraints required to implement the "gives" relationship

-- This constraint ensures that the foreign key of table "DISCOUNT"
-- correctly references the primary key of table "TRADER"

ALTER TABLE DISCOUNT ADD CONSTRAINT fk1_DISCOUNT_to_TRADER FOREIGN KEY(fk1_User_Id) REFERENCES TRADER(User_Id);

-- Alter table to add new constraints required to implement the "can_have" relationship

-- This constraint ensures that the foreign key of table "WISHLIST"
-- correctly references the primary key of table "CUSTOMER"

ALTER TABLE WISHLIST ADD CONSTRAINT fk1_WISHLIST_to_CUSTOMER FOREIGN KEY(fk1_User_Id) REFERENCES CUSTOMER(User_Id);

-- Alter table to add new constraints required to implement the "is_alloted" relationship

-- This constraint ensures that the foreign key of table "CART"
-- correctly references the primary key of table "CUSTOMER"

ALTER TABLE CART ADD CONSTRAINT fk1_CART_to_CUSTOMER FOREIGN KEY(fk1_User_Id) REFERENCES CUSTOMER(User_Id);

-- Alter table to add new constraints required to implement the "can_browse_through" relationship

-- This constraint ensures that the foreign key of table "SHOP"
-- correctly references the primary key of table "USER"

ALTER TABLE SHOP ADD CONSTRAINT fk1_SHOP_to_USERS FOREIGN KEY(fk1_User_Id) REFERENCES USERS(User_Id);

-- Alter table to add new constraints required to implement the "can_make" relationship

-- This constraint ensures that the foreign key of table "PAYMENT"
-- correctly references the primary key of table "CUSTOMER"

ALTER TABLE PAYMENT ADD CONSTRAINT fk1_PAYMENT_to_CUSTOMER FOREIGN KEY(fk1_User_Id) REFERENCES CUSTOMER(User_Id);

-- Alter table to add new constraints required to implement the "is_acknowledged_by" relationship

-- This constraint ensures that the foreign key of table "RECEIPT"
-- correctly references the primary key of table "USER"

ALTER TABLE RECEIPT ADD CONSTRAINT fk1_RECEIPT_to_USER FOREIGN KEY(fk1_User_Id) REFERENCES USERS(User_Id);

-- Alter table to add new constraints required to implement the "generates" relationship

-- This constraint ensures that the foreign key of table "RECEIPT"
-- correctly references the primary key of table "PAYMENT"

ALTER TABLE RECEIPT ADD CONSTRAINT fk2_RECEIPT_to_PAYMENT FOREIGN KEY(fk2_Payment_Id) REFERENCES PAYMENT(Payment_Id);

-- Alter table to add new constraints required to implement the "can_contain" relationship

-- This constraint ensures that the foreign key of table "CART_PRODUCT"
-- correctly references the primary key of table "CART"

ALTER TABLE CART_PRODUCT ADD CONSTRAINT fk1_CART_PRODUCT_to_CART FOREIGN KEY(fk1_Cart_Id) REFERENCES CART(Cart_Id);

-- Alter table to add new constraints required to implement the "is_associated_to" relationship

-- This constraint ensures that the foreign key of table "CART_PRODUCT"
-- correctly references the primary key of table "PRODUCT"

ALTER TABLE CART_PRODUCT ADD CONSTRAINT fk2_CART_PRODUCT_to_PRODUCT FOREIGN KEY(fk2_Product_Id) REFERENCES PRODUCT(Product_Id);

-- Alter table to add new constraints required to implement the "ORDER_PRODUCT_PRODUCT" relationship

-- This constraint ensures that the foreign key of table "ORDER_PRODUCT"
-- correctly references the primary key of table "PRODUCT"

ALTER TABLE ORDERS_PRODUCT ADD CONSTRAINT fk1_ORDER_PRODUCT_to_PRODUCT FOREIGN KEY(fk1_Product_Id) REFERENCES PRODUCT(Product_Id);

-- Alter table to add new constraints required to implement the "is_associated_to" relationship

-- This constraint ensures that the foreign key of table "PAYMENT"
-- correctly references the primary key of table "ORDER"

ALTER TABLE PAYMENT ADD CONSTRAINT fk2_PAYMENT_to_ORDER FOREIGN KEY(fk2_Order_Id) REFERENCES ORDERS(Order_Id);

-- Alter table to add new constraints required to implement the "determines" relationship

-- This constraint ensures that the foreign key of table "COLLECTION_POINT"
-- correctly references the primary key of table "PAYMENT"

ALTER TABLE COLLECTION_POINT ADD CONSTRAINT fk1_COLLECTION_POINT_to_PAYMENT FOREIGN KEY(fk1_Payment_Id) REFERENCES PAYMENT(Payment_Id);

-- Alter table to add new constraints required to implement the "is_inclusive_of" relationship

-- This constraint ensures that the foreign key of table "WISHLIST_PRODUCT"
-- correctly references the primary key of table "PRODUCT"

ALTER TABLE WISHLIST_PRODUCT ADD CONSTRAINT fk1_WISHLIST_PRODUCT_to_PRODUCT FOREIGN KEY(fk1_Product_Id) REFERENCES PRODUCT(Product_Id);

-- Alter table to add new constraints required to implement the "is_inclusive_of" relationship

-- This constraint ensures that the foreign key of table "WISHLIST_PRODUCT"
-- correctly references the primary key of table "WISHLIST"

ALTER TABLE WISHLIST_PRODUCT ADD CONSTRAINT fk2_WISHLIST_PRODUCT_to_WISHLIST FOREIGN KEY(fk2_Wishlist_Id) REFERENCES WISHLIST(Wishlist_Id);

-- Alter table to add new constraints required to implement the "belongs_to" relationship

-- This constraint ensures that the foreign key of table "PRODUCT"
-- correctly references the primary key of table "PRODUCT_TYPE"

ALTER TABLE PRODUCT ADD CONSTRAINT fk2_PRODUCT_to_PRODUCT_TYPE FOREIGN KEY(fk2_Product_Type_Id) REFERENCES PRODUCT_TYPE(Product_Type_Id);


--------------------------------------------------------------
-- End of DDL file auto-generation
--------------------------------------------------------------*/
